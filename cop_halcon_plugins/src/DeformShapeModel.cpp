/*
 * Copyright (C) 2009 by Ulrich Friedrich Klank <klank@in.tum.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/*#ifdef DEFORMSHAPE_AVAILABLE*/
#include "DeformShapeModel.h"
#include "XMLTag.h"
#include "Camera.h"
#include "RelPoseHTuple.h"

#include "cpp/HalconCpp.h"
using namespace Halcon;



#define XML_NODE_FILENAME "filename"
#define XML_NODE_XNORM "xnorm"
#define XML_NODE_YNORM "ynorm"

#define XML_ATTRIBUTE_AUTOGENERATED "auto"
#define XML_NODE_PLANARCOMPENSATION  "PlanarCompensation"
#define XML_NODE_INHERITCOV "InheritCov"
using namespace cop;


DeformShapeModel::DeformShapeModel(Class* classref) :
	Descriptor(classref),
	m_bWritten(false),
	m_regionTemp(NULL),
	m_autoLearned(true)
{
              
	/*
	sig->Get
	create_planar_uncalib_deformable_model();
	*/
}

DeformShapeModel::DeformShapeModel() :
  m_bWritten(false),
  m_regionTemp(NULL),
  m_autoLearned(true)
{

}

long DeformShapeModel::GetDeformShapeHandle(std::string sensor_id)
{
  if(m_models.find(sensor_id) != m_models.end())
  {
     return  m_models[sensor_id].m_handle;
  }
  else if(m_models.find("default") != m_models.end())
  {
     return  m_models["default"].m_handle;
  }
  else
  {
     return -1;
  }
}


void DeformShapeModel::SetData(XMLTag* tag)
{
	Descriptor::SetData(tag),
	m_filename = "";


  if(tag != NULL)
  {
    int i = 0;
    while(tag != NULL)
    {
      XMLTag* xml_filename = tag->GetChild(XML_NODE_FILENAME, i++);
      if(xml_filename != NULL)
      {
          m_filename = xml_filename->GetCDataST();
          if(LoadFromFile(m_filename, xml_filename->GetProperty(XML_PROPERTY_SENSORNAME, "default")))
          {
             m_bWritten = true;
          }

      }
      else
       break;
    }

    m_autoLearned = tag->GetProperty(XML_ATTRIBUTE_AUTOGENERATED, "false").compare("true") == 0 ? true : false;
  }

  XMLTag* hommat_tag = tag->GetChild(XML_NODE_PLANARCOMPENSATION);
  if(hommat_tag != NULL)
  {
    m_planarAssumtionCompensation = XMLTag::Load(hommat_tag, &m_planarAssumtionCompensation);
  }
  else
  {
    /** Rotate locally around y by M_PI*/
    m_planarAssumtionCompensation = IdentityMatrix(4);
    m_planarAssumtionCompensation.element(0,0) = -1.0;
    m_planarAssumtionCompensation.element(2,2) = -1.0;
  }
  XMLTag* cov_tag = tag->GetChild(XML_NODE_INHERITCOV);
  if(cov_tag != NULL)
  {
    m_covInherit = XMLTag::Load(cov_tag, &m_covInherit);
  }
  else
  {
    /** Rotate locally around y by M_PI*/
    m_covInherit = IdentityMatrix(6);
    m_covInherit.element(0,0) = 0.001;
    m_covInherit.element(1,1) = 0.001;
    m_covInherit.element(2,2) = 0.03;
    m_covInherit.element(3,3) = 0.1;
    m_covInherit.element(4,4) = 0.1;
    m_covInherit.element(5,5) = 0.001;
  }

}

DeformShapeModel::~DeformShapeModel(void)
{
  std::map<std::string, SensorSpecificDeformModel>::const_iterator iter = m_models.begin();
  for( ;iter != m_models.end(); iter++)
  {
    try
    {
      clear_deformable_model((*iter).second.m_handle);
    }
    catch(Halcon::HException ex)
    {
      printf("Trying to delete an invalid deformable shape model: %s\n", ex.message);
    }
  }
  delete m_regionTemp;
}

bool DeformShapeModel::LoadFromFile(std::string fileName, std::string stSensorID)
{
  Hlong id;
  std::pair<std::string, std::vector< double> > vec_temp;
  try
  {
    Halcon::HTuple tup;
    read_deformable_model(fileName.c_str(), &id);
    try
    {
      get_deformable_model_params (id, "cam_param", &tup);
      vec_temp.first = "RECTHALCONCALIB";
      vec_temp.second.push_back( tup[0].D());
      vec_temp.second.push_back( tup[2].D());
      vec_temp.second.push_back( tup[3].D());
      vec_temp.second.push_back( tup[4].D());
      vec_temp.second.push_back( tup[5].D());
      vec_temp.second.push_back( tup[6].D());
      vec_temp.second.push_back( tup[7].D());

    }
    catch(Halcon::HException ex)
    {
      printf("Uncalib model! \n");

    }
    m_bWritten = true;
  }
  catch(Halcon::HException ex)
  {
    printf("Error reading DeformShapeModel from file: %s (Error message %s)\n", fileName.c_str(), ex.message);
    return false;
  }
  m_models[stSensorID].m_handle = id;
  if(vec_temp.second.size() > 0)
    m_models[stSensorID].m_calib = MinimalCalibration(vec_temp);
  return true;
}

void DeformShapeModel::Show(RelPose* pose, Sensor* camin)
{

  if(camin != NULL && camin->IsCamera())
  {
    Camera* cam = (Camera*)camin;
    Hobject xld;
  //get_deformable_model_contours(&xld, m_handle, 1);
    try
    {
      printf("In DeformShapeModel::Show\n");
      HWindow* hwin = cam->GetWindow();
      hwin->SetColor("red");
      hwin->SetLineWidth(3);
      HTuple row, col, pose_ht,HomMat3DToWorld, CamParam = cam->m_calibration.CamParam();
      RelPoseHTuple::GetPose(pose, &pose_ht, cam->m_relPose->m_uniqueID);
      RelPoseHTuple::GetHommat(pose, &HomMat3DToWorld, ID_WORLD);

      HTuple HomMat3Dt;
      /* Pose in is with z up, we need z orhogonal to the plane*/
      pose_to_hom_mat3d (pose_ht, &HomMat3Dt);
      printf("Before: \n");
      for(int k = 0; k< 6; k++)printf("%f ", pose_ht[k].D());

      printf("\n");

      hom_mat3d_compose(HomMat3Dt, RelPoseHTuple::m2HT(m_planarAssumtionCompensation.i()), &HomMat3Dt);
      cout << "Compensation" << endl << m_planarAssumtionCompensation.i() << endl;
      hom_mat3d_to_pose (HomMat3Dt, &pose_ht);

      printf("After:\n");
      for(int k = 0; k< 6; k++)printf("%f ", pose_ht[k].D());
      printf("\n");



      long handle;
      if(m_models.find(camin->GetSensorID()) != m_models.end())
      {
        handle = m_models[camin->GetSensorID()].m_handle;
      }
      else if (m_models.find("default") != m_models.end())
      {
        handle = m_models["default"].m_handle;
      }
      else
      {
        printf("No valid model to show Deform Shape Model\n");
        return;
      }
      project_3d_point(pose_ht[0],pose_ht[1], pose_ht[2], CamParam, &row, &col);
      disp_cross(hwin->WindowHandle(), row, col, 60, 0.79);

      HTuple ModelRow, ModelCol, ModelPose, hom2d(6), NumberContour, HomMat3D, ModelCamParam;
      Hobject ModelContours, ContoursAffinTrans, ContoursTrans, FoundContour, ObjectSelected;

      get_deformable_model_contours (&ModelContours, handle, 1);
      get_deformable_model_params (handle, "model_row", &ModelRow);
      get_deformable_model_params (handle, "model_col", &ModelCol);
      try
      {
        get_deformable_model_params (handle, "cam_param", &ModelCamParam);
        get_deformable_model_params (handle, "model_pose", &ModelPose);

      }
      catch(HException ex)
      {
        printf("Deform shape model is uncalibrated and can not be dispalyed in 3D\n");
        return;
      }

      hom2d[0] = 1;hom2d[1] = 0;hom2d[2] = ModelRow;hom2d[3] = 0; hom2d[4] = 1; hom2d[5] = ModelCol;

      affine_trans_contour_xld (ModelContours, &ContoursAffinTrans, hom2d);
      contour_to_world_plane_xld (ContoursAffinTrans, &ContoursTrans, ModelCamParam, ModelPose, "m");
      count_obj (ContoursTrans, &NumberContour);
      pose_to_hom_mat3d (pose_ht, &HomMat3D);

      /* Pose in is with z up, we need z orhogonal to the plane*/
      /*hom_mat3d_compose(HomMat3D, RelPoseHTuple::m2HT(m_planarAssumtionCompensation.i()), &HomMat3D);*/
      hom_mat3d_compose(HomMat3DToWorld, RelPoseHTuple::m2HT(m_planarAssumtionCompensation.i()), &HomMat3DToWorld);


      /*Halcon::hom_mat3d_rotate_local(HomMat3D, -M_PI, "y", &HomMat3D);
      Halcon::hom_mat3d_rotate_local(HomMat3DToWorld, -M_PI, "y", &HomMat3DToWorld);*/
      printf("pose: %f %f %f\n", HomMat3D[3].D(), HomMat3D[7].D(), HomMat3D[11].D());
      printf("CamParam: %f %f %f %f %f %f\n", CamParam[0].D(), CamParam[1].D(), CamParam[2].D(), CamParam[3].D(), CamParam[4].D(), CamParam[5].D());
      gen_empty_obj (&FoundContour);
      std::vector<double> x,y,z;
      for (int index = 1; index <= NumberContour; index++)
      {
        HTuple X,Y,Z, Xc, Yc, Zc, R, C, Xworld, Yworld, Zworld;
        Hobject ModelWorld;
        select_obj (ContoursTrans, &ObjectSelected, index);
        get_contour_xld (ObjectSelected, &Y, &X);
        Halcon::tuple_gen_const(X.Num(), 0.0, &Z);
        affine_trans_point_3d (HomMat3D, X, Y, Z, &Xc, &Yc, &Zc);
        affine_trans_point_3d (HomMat3DToWorld, X, Y, Z, &Xworld, &Yworld, &Zworld);
        for(int i = 0; i < Xworld.Num(); i++)
        {
          x.push_back(Xworld[i].D());
          y.push_back(Yworld[i].D());
          z.push_back(Zworld[i].D());
        }
        project_3d_point (Xc, Yc, Zc, CamParam, &R, &C);
        gen_contour_polygon_xld (&ModelWorld, R, C);
        concat_obj (FoundContour, ModelWorld, &FoundContour);
      }
      cam->Publish3DData(x,y,z);

      disp_obj(FoundContour, hwin->WindowHandle());

      if(m_regionTemp != NULL)
      {
        hwin->SetDraw("margin");
         disp_obj( *m_regionTemp, hwin->WindowHandle());
         delete m_regionTemp;
         m_regionTemp = NULL;
      }
      hwin->SetLineWidth(1);
    }
    catch(Halcon::HException ex)
    {
      printf("Problems showing DeformShapeModel: %s\n", ex.message);
    }
    catch(const char *text)
    {
      printf("Problems showing DeformShapeModel: %s\n", text);
    }
  }

}


double DeformShapeModel::DefineDeformShapeModel(Image* image, Halcon::Hobject* region, Camera* cam, RelPose* pose, Matrix planarAssumtionCompensation)
{
  Halcon::HTuple score;
  m_autoLearned = true;
  try
  {
    Halcon::Hobject imgReduced, *img;
    Halcon::HTuple  autoTuple, empty, model_id, pose_in, pose_out, cov, hom, hom_new;
    if(m_regionTemp == NULL)
      m_regionTemp = new Halcon::Hobject();

    RelPose* pose_image = image->GetPose();
    RelPoseHTuple::GetPose(pose, &pose_in, pose_image->m_uniqueID);
    /** We assume the provided pose to be already perfect*/
    /*Halcon::pose_to_hom_mat3d(pose_in, &hom);
    Halcon::hom_mat3d_rotate_local(hom, M_PI, "y", &hom_new);
    Halcon::hom_mat3d_to_pose(hom_new, &pose_in);*/
    img = image->GetHImage();
    if(m_models.size() > 0)
    {
      SensorSpecificDeformModel& sensmodel = GetDeformShapeModel();
      if(!sensmodel.IsCompatible(cam))
      {
        printf( "DeformShape Model not valid for this sensor\n");
        return 0.0;
      }
      model_id = sensmodel.m_handle;
      Halcon::dilation_circle(*region,m_regionTemp, 30);
      Halcon::reduce_domain(*img, *m_regionTemp, &imgReduced);
      Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.2,0.2,0.9,
                            1.1,0.9,1.1,0.5,1,1,0,0.9, empty, empty, &pose_out, &cov, &score);
      if(pose_out.Num() < 6)
      {
          printf("Trying again with larger search space and lower thresholds\n");
          Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.2,0.2,0.9,
                                    1.1,1.0,1.0,0.05,1,1,0,0.1, empty, empty, &pose_out, &cov, &score);
          if(pose_out.Num() < 6)
          {
            printf( "DeformShape Model not valid for this sensor\n");
            return 0.0;
          }
      }
      /*Save the model ID*/
      m_models[cam->GetSensorID()].m_handle = model_id[0].I();
      m_models[cam->GetSensorID()].m_calib = sensmodel.m_calib;
      printf("Model valid for Sensor %s: %d (Number of valid sensors = %ld)\n", cam->GetSensorID().c_str(), model_id[0].I(), m_models.size());

    }
    else
    {
      /*reduce region of interest to a selected part of the image, that will be used for generating the model*/
      Halcon::erosion_circle(*region,m_regionTemp, 5);
      Halcon::reduce_domain(*img, *m_regionTemp, &imgReduced);
      /*temp varibale for constant auto*/
      autoTuple = "auto";
      /*Create the model*/
      Halcon::create_planar_calib_deformable_model(imgReduced, cam->m_calibration.CamParam(), pose_in, autoTuple,
          -0.8, 0.8, autoTuple, 0.8 , 1.2, autoTuple, 0.8,1.2,
          autoTuple,"point_reduction_low", "use_polarity", autoTuple,autoTuple, empty,empty,&model_id);
          printf("creating worked\n");
      /*Calculate the homography that is needed as starting value for tracking*/
      Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.01,0.01,0.9,
                            1.1,1.0,1.0,0.8,1,1,0,0.9, empty, empty, &pose_out, &cov, &score);
      if(pose_out.Num() < 6)
      {
          Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.01,0.01,0.9,
                                    1.1,1.0,1.0,0.05,1,1,0,0.1, empty, empty, &pose_out, &cov, &score);
          if(pose_out.Num() < 6)
          {
            XMLTag* tag = image->Save();
            std::string filename = tag->GetProperty(XML_ATTRIBUTE_FILENAME, "no image");
            printf("Saved failed image at: %s\n", filename.c_str());
            write_region(*m_regionTemp, HTuple(filename.c_str()) + ".reg");
            printf("Saved failed image at: %s\n", HTuple(HTuple(filename.c_str()) + ".reg")[0].S());
            delete tag;

            throw "DeformShape Model not valid";
          }
      }
      printf("Compare Pose_in with Pose_out:\n %f - %f = %f\n %f - %f = %f\n %f - %f = %f\n", pose_in[0].D(), pose_out[0].D(), pose_in[0].D() - pose_out[0].D(), pose_in[1].D() , pose_out[1].D(), pose_in[1].D() - pose_out[1].D(), pose_in[2].D(), pose_out[2].D(), pose_in[2].D() - pose_out[2].D());
      /*Save the model ID*/
      m_models[cam->GetSensorID()].m_handle = model_id[0].I();
      m_models[cam->GetSensorID()].m_calib = MinimalCalibration(cam->GetUnformatedCalibrationValues());
      printf("Created Model for Sensor %s: %d (Number of models = %ld)\n", cam->GetSensorID().c_str(), model_id[0].I(), m_models.size());
      m_planarAssumtionCompensation = planarAssumtionCompensation;
    }
  }
  catch(HException ex)
  {
     ROS_WARN("Error Learning Deform Shape Model: %s\n", ex.message);
     throw "Error Learning Deform Shape Model";
  }
  catch(const char* text)
  {
    printf("Error building deform shape: %s\n", text);
    return 0.0;
  }
  if(score.Num() > 0)
    return score[0].D();
  else
    return 0.0;
}


void DeformShapeModel::SaveTo(XMLTag* tag)
{
  Descriptor::SaveTo(tag);
  std::map<std::string, SensorSpecificDeformModel>::const_iterator iter = m_models.begin();
  for( ;iter != m_models.end(); iter++)
  {
      try
      {
        std::stringstream st;
        st << m_class->GetName() <<"_" << (*iter).first << ".dfm";
        std::string test  = st.str();
        size_t index = -1;
        while((index = test.find_first_of("/")) != test.npos)
        {
          test = test.replace(index, 1, "_");
        }
        m_filename = test;
        printf("write deform to %s\n", m_filename.c_str());
        FILE* ftest = fopen(m_filename.c_str(), "r");
        if(!m_bWritten || !ftest)
        {
          Halcon::write_deformable_model((*iter).second.m_handle, m_filename.c_str());
        }
        if(ftest)
          fclose(ftest);

        XMLTag* child = XMLTag::Tag(m_filename, XML_NODE_FILENAME);
        child->AddProperty(XML_PROPERTY_SENSORNAME, (*iter).first);
        tag->AddChild(child);
      }
      catch(Halcon::HException ex)
      {
        printf("DeformShapeModel::SaveTo: Error: %s  (filename: %s)\n", ex.message, m_filename.c_str());
      }
  }
  m_bWritten = true;
  tag->AddProperty(XML_ATTRIBUTE_AUTOGENERATED, (m_autoLearned ? "true" : "false"));
  tag->AddChild(XMLTag::Tag(m_planarAssumtionCompensation, XML_NODE_PLANARCOMPENSATION));
  tag->AddChild(XMLTag::Tag(m_covInherit, XML_NODE_INHERITCOV));
}

Elem* DeformShapeModel::Duplicate(bool staticcopy)
{
  DeformShapeModel* new_obj = new DeformShapeModel();


  /** Assign Descriptor Memebers*/
  if(staticcopy)
  {
    new_obj->m_ID = m_ID;
  }

  new_obj->m_class = m_class;
  new_obj->m_imgLastMatchReading = m_imgLastMatchReading == NULL ? NULL : m_imgLastMatchReading->Clone();

  new_obj->m_poseLastMatchReading = m_poseLastMatchReading == NULL ? NULL :  RelPoseFactory::CloneRelPose(m_poseLastMatchReading);
  new_obj->m_qualityMeasure = m_qualityMeasure;

  new_obj->m_models = m_models;
  new_obj->m_filename = m_filename;
  new_obj->m_bWritten = m_bWritten;
  new_obj->m_regionTemp = NULL;
  new_obj->m_autoLearned = m_autoLearned;
  new_obj->m_planarAssumtionCompensation = m_planarAssumtionCompensation;
  return (Elem*)new_obj;
}
/*#endif*/ /*DEFORMSHAPE_AVAILABLE*/


