///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 10.0
///////////////////////////////////////////////////////////////////////////////



#include "cpp/HalconCpp.h"



using namespace Halcon;

// Procedure declarations
void extract_long_lines (Halcon::Hobject ImageReducedL, Halcon::Hobject *SelectedXLD1);
void vectorized_cross_product (Halcon::HTuple XL1, Halcon::HTuple YL1, Halcon::HTuple ZL1,
    Halcon::HTuple XL2, Halcon::HTuple YL2, Halcon::HTuple ZL2, Halcon::HTuple *VCX,
    Halcon::HTuple *VCY, Halcon::HTuple *VCZ);
void vectorized_all_cross_product (Halcon::HTuple XL, Halcon::HTuple YL, Halcon::HTuple ZL,
    Halcon::HTuple XR, Halcon::HTuple YR, Halcon::HTuple ZR, Halcon::HTuple *VCX,
    Halcon::HTuple *VCY, Halcon::HTuple *VCZ);
void vectorized_all_scalar (Halcon::HTuple TRW, Halcon::HTuple VCX, Halcon::HTuple VCY,
    Halcon::HTuple VCZ, Halcon::HTuple *VVPX, Halcon::HTuple *VVPY, Halcon::HTuple *VVPZ);
void vectorized_norm (Halcon::HTuple VCX, Halcon::HTuple VCY, Halcon::HTuple VCZ,
    Halcon::HTuple *VCXNorm, Halcon::HTuple *VCYNorm, Halcon::HTuple *VCZNorm);
void intersect_line3d (Halcon::HTuple a, Halcon::HTuple u, Halcon::HTuple b, Halcon::HTuple v,
    Halcon::HTuple *ret);
void find_lines (Halcon::Hobject ImageReducedL, Halcon::Hobject ImageReducedR, Halcon::HTuple CamParamL,
    Halcon::HTuple CamParamR, Halcon::HTuple Pose, Halcon::HTuple *XFinal1, Halcon::HTuple *YFinal1,
    Halcon::HTuple *ZFinal1, Halcon::HTuple *XFinal2, Halcon::HTuple *YFinal2, Halcon::HTuple *ZFinal2);
// Procedures
void extract_long_lines (Halcon::Hobject ImageReducedL, Halcon::Hobject *SelectedXLD1)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  EdgesL, UnionContours, ContoursSplitL, Region1, ImageReduced, RegionClosing, RegionDilation, RegionClosing2, RegionDifference, RegionFilled, Holes, HolesCon;


  // Local control variables
  HTuple  Length, Mean, Deviation, NumHoles;

  bin_threshold (ImageReducedL, &Region1);
  closing_circle (Region1, &RegionClosing, 8);

  fill_up(Region1, &RegionFilled);
  difference(RegionFilled, Region1, &Holes);
  connection(Holes, &HolesCon);
  count_obj(HolesCon, &NumHoles);
  if(NumHoles[0].I() == 1)
  {
     //todo check for empty obj...
  }
  printf("\n\n Number of Holes: %d\n\n", NumHoles[0].I());

  dilation_circle (RegionClosing, &RegionDilation, 8);
  erosion_circle (RegionClosing, &RegionClosing2, 8);
  difference (RegionDilation, RegionClosing2, &RegionDifference);
  reduce_domain (ImageReducedL, RegionDifference, &ImageReduced);

  write_image (ImageReduced, "tiff", 0, "test_image_in_edges.tif");
  edges_sub_pix(ImageReduced, &EdgesL, "canny", 1, 20, 40);
  union_adjacent_contours_xld(EdgesL, &UnionContours, 14, 7, "attr_keep");
  segment_contours_xld(UnionContours, &ContoursSplitL, "lines", 5, 4, 2);
  length_xld(ContoursSplitL, &Length);
   printf("Line candidates: %ld\n",Length.Num());
  if(Length.Num() > 0)
  {
    tuple_mean(Length, &Mean);
    tuple_deviation(Length, &Deviation);
    select_shape_xld(ContoursSplitL, SelectedXLD1, "contlength", "and", Mean-(0.5*Deviation),
      100+Mean+(10*Deviation));
  }
  return;
}

void vectorized_cross_product (Halcon::HTuple XL1, Halcon::HTuple YL1, Halcon::HTuple ZL1,
    Halcon::HTuple XL2, Halcon::HTuple YL2, Halcon::HTuple ZL2, Halcon::HTuple *VCX,
    Halcon::HTuple *VCY, Halcon::HTuple *VCZ)
{
  using namespace Halcon;
  (*VCX) = (YL1*ZL2)-(ZL1*YL2);
  (*VCY) = (ZL1*XL2)-(XL1*ZL2);
  (*VCZ) = (XL1*YL2)-(YL1*XL2);
  return;
}

void vectorized_all_cross_product (Halcon::HTuple XL, Halcon::HTuple YL, Halcon::HTuple ZL,
    Halcon::HTuple XR, Halcon::HTuple YR, Halcon::HTuple ZR, Halcon::HTuple *VCX,
    Halcon::HTuple *VCY, Halcon::HTuple *VCZ)
{
  using namespace Halcon;

  // Local control variables
  HTuple  i;

  (*VCX) = HTuple();
  (*VCY) = HTuple();
  (*VCZ) = HTuple();
  for (i=0; i<=(YL.Num())-1; i+=1)
  {
    (*VCX).Append((HTuple(YL[i])*ZR)-(HTuple(ZL[i])*YR));
    (*VCY).Append((HTuple(ZL[i])*XR)-(HTuple(XL[i])*ZR));
    (*VCZ).Append((HTuple(XL[i])*YR)-(HTuple(YL[i])*XR));
  }
  return;
}

void vectorized_all_scalar (Halcon::HTuple TRW, Halcon::HTuple VCX, Halcon::HTuple VCY,
    Halcon::HTuple VCZ, Halcon::HTuple *VVPX, Halcon::HTuple *VVPY, Halcon::HTuple *VVPZ)
{
  using namespace Halcon;

  // Local control variables
  HTuple  i;

  (*VVPX) = HTuple();
  (*VVPY) = HTuple();
  (*VVPZ) = HTuple();
  for (i=0; i<=(VCX.Num())-1; i+=1)
  {
    (*VVPX).Append(TRW*HTuple(VCX[i]));
    (*VVPY).Append(TRW*HTuple(VCY[i]));
    (*VVPZ).Append(TRW*HTuple(VCZ[i]));
  }
  return;
}

void vectorized_norm (Halcon::HTuple VCX, Halcon::HTuple VCY, Halcon::HTuple VCZ,
    Halcon::HTuple *VCXNorm, Halcon::HTuple *VCYNorm, Halcon::HTuple *VCZNorm)
{
  using namespace Halcon;

  // Local control variables
  HTuple  t;

  t = (((VCX*VCX)+(VCY*VCY))+(VCZ*VCZ)).Sqrt();
  (*VCXNorm) = VCX/t;
  (*VCYNorm) = VCY/t;
  (*VCZNorm) = VCZ/t;
  return;
}

void intersect_line3d (Halcon::HTuple a, Halcon::HTuple u, Halcon::HTuple b, Halcon::HTuple v,
    Halcon::HTuple *ret)
{
  using namespace Halcon;

  // Local control variables
  HTuple  d, sdu, sdv, suu, svv, suv, s, mu, lm;

  d = b-a;
  sdu = (d*u).Sum();
  sdv = (d*v).Sum();
  suu = (u*u).Sum();
  svv = (v*v).Sum();
  suv = (u*v).Sum();
  s = 1/((suv*suv)-(suu*svv));
  mu = ((sdv*suu)-(sdu*suv))*s;
  lm = (((-sdu)*svv)+(sdv*suv))*s;
  (*ret) = 0.5*(((b+a)+(lm*u))+(mu*v));
  return;
}

void find_lines_1image (Halcon::Hobject ImageReducedL, Halcon::HTuple CamParamL, Halcon::HTuple hommat,
    Halcon::HTuple &XL1, Halcon::HTuple &YL1, Halcon::HTuple &ZL1, Halcon::HTuple &XL2, Halcon::HTuple &YL2, Halcon::HTuple &ZL2)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  LongLinesL, LongLinesR;


  // Local control variables
  HTuple  RowBeginL, ColBeginL, RowEndL, ColEndL;
  HTuple  NrL, NcL, DistL,  pose;

  hom_mat3d_to_pose (hommat, &pose);
  try
  {
    extract_long_lines(ImageReducedL, &LongLinesL);

    fit_line_contour_xld(LongLinesL, "tukey", -1, 0, 5, 2, &RowBeginL, &ColBeginL,
      &RowEndL, &ColEndL, &NrL, &NcL, &DistL);
  }
  catch(HException ex)
  {
    printf("Error  in find_lines: %s \n", ex.message);
  }

  image_points_to_world_plane(CamParamL, pose,
      RowBeginL, ColBeginL, "m", &XL1, &YL1);
   image_points_to_world_plane(CamParamL, pose,
      RowEndL, ColEndL, "m", &XL2, &YL2);
  tuple_gen_const(XL1.Num(), 0.0, &ZL1);
  tuple_gen_const(XL2.Num(), 0.0, &ZL2);



}

void find_lines (Halcon::Hobject ImageReducedL, Halcon::Hobject ImageReducedR, Halcon::HTuple CamParamL,
    Halcon::HTuple CamParamR, Halcon::HTuple Pose, Halcon::HTuple *XFinal1, Halcon::HTuple *YFinal1,
    Halcon::HTuple *ZFinal1, Halcon::HTuple *XFinal2, Halcon::HTuple *YFinal2, Halcon::HTuple *ZFinal2)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  LongLinesL, LongLinesR;


  // Local control variables
  HTuple  RowBeginR, ColBeginR, RowEndR, ColEndR;
  HTuple  NrR, NcR, DistR, RowBeginL, ColBeginL, RowEndL;
  HTuple  ColEndL, NrL, NcL, DistL, XL1, YL1, XL2, YL2, XR1;
  HTuple  YR1, XR2, YR2, ZL1, ZL2, ZR1, ZR2, XL3, YL3, ZL3;
  HTuple  XR3, YR3, ZR3, VCXUn, VCYUn, VCZUn, VRXUn, VRYUn;
  HTuple  VRZUn, VCX, VCY, VCZ, VRX, VRY, VRZ, HomMat3D, VRW;
  HTuple  MatrixID, MatrixID2, MatrixMultID, Values, TRX;
  HTuple  TRY, TRZ, TRW, VCrossX, VCrossY, VCrossZ, VVPX;
  HTuple  VVPY, VVPZ, P0X, P0Y, P0Z, len, i, j, index, a;
  HTuple  u, b, v, ret;
  try
  {
    extract_long_lines(ImageReducedL, &LongLinesL);
    extract_long_lines(ImageReducedR, &LongLinesR);

    fit_line_contour_xld(LongLinesR, "tukey", -1, 0, 5, 2, &RowBeginR, &ColBeginR,
      &RowEndR, &ColEndR, &NrR, &NcR, &DistR);

    fit_line_contour_xld(LongLinesL, "tukey", -1, 0, 5, 2, &RowBeginL, &ColBeginL,
      &RowEndL, &ColEndL, &NrL, &NcL, &DistL);
    printf("Found %ld line in first image and %ld  in second\n", RowBeginR.Num(), RowBeginL.Num());
  }
  catch(HException ex)
  {
    printf("Error  in find_lines: %s \n", ex.message);
  }

  image_points_to_world_plane(CamParamL, ((HTuple(0).Append(0)).Concat(HTuple(CamParamL[0]))).Concat((((HTuple(0).Append(0)).Append(0)).Append(0))),
      RowBeginL, ColBeginL, "m", &XL1, &YL1);
  image_points_to_world_plane(CamParamL, ((HTuple(0).Append(0)).Concat(HTuple(CamParamL[0]))).Concat((((HTuple(0).Append(0)).Append(0)).Append(0))),
      RowEndL, ColEndL, "m", &XL2, &YL2);
  image_points_to_world_plane(CamParamR, ((HTuple(0).Append(0)).Concat(HTuple(CamParamR[0]))).Concat((((HTuple(0).Append(0)).Append(0)).Append(0))),
      RowBeginR, ColBeginR, "m", &XR1, &YR1);
  image_points_to_world_plane(CamParamR, ((HTuple(0).Append(0)).Concat(HTuple(CamParamR[0]))).Concat((((HTuple(0).Append(0)).Append(0)).Append(0))),
      RowEndR, ColEndR, "m", &XR2, &YR2);

  tuple_gen_const(XL1.Num(), HTuple(CamParamL[0]), &ZL1);
  tuple_gen_const(XL2.Num(), HTuple(CamParamL[0]), &ZL2);
  tuple_gen_const(XR1.Num(), HTuple(CamParamR[0]), &ZR1);
  tuple_gen_const(XR2.Num(), HTuple(CamParamR[0]), &ZR2);

  tuple_gen_const(ZL1.Num(), 0, &XL3);
  tuple_gen_const(ZL1.Num(), 0, &YL3);
  tuple_gen_const(ZL1.Num(), 0, &ZL3);

  tuple_gen_const(ZR1.Num(), 0, &XR3);
  tuple_gen_const(ZR1.Num(), 0, &YR3);
  tuple_gen_const(ZR1.Num(), 0, &ZR3);

  vectorized_cross_product(XL1, YL1, ZL1, XL2, YL2, ZL2, &VCXUn, &VCYUn, &VCZUn);
  vectorized_cross_product(XR1, YR1, ZR1, XR2, YR2, ZR2, &VRXUn, &VRYUn, &VRZUn);

  vectorized_norm(VCXUn, VCYUn, VCZUn, &VCX, &VCY, &VCZ);
  vectorized_norm(VRXUn, VRYUn, VRZUn, &VRX, &VRY, &VRZ);

  pose_to_hom_mat3d(Pose, &HomMat3D);
  tuple_gen_const(VRX.Num(), 0, &VRW);
  create_matrix(4, 4, HomMat3D.Concat((((HTuple(0).Append(0)).Append(0)).Append(1))),
      &MatrixID);
  create_matrix(4, VRX.Num(), ((VRX.Concat(VRY)).Concat(VRZ)).Concat(VRW), &MatrixID2);
  mult_matrix(MatrixID, MatrixID2, "ATB", &MatrixMultID);
  get_full_matrix(MatrixMultID, &Values);

  TRX = Values(0,(VRX.Num())-1);
  TRY = Values(VRX.Num(),(2*(VRX.Num()))-1);
  TRZ = Values(2*(VRX.Num()),(3*(VRX.Num()))-1);
  TRW = Values(3*(VRX.Num()),(4*(VRX.Num()))-1);

  vectorized_all_cross_product(VCX, VCY, VCZ, TRX, TRY, TRZ, &VCrossX, &VCrossY,
      &VCrossZ);
  vectorized_all_scalar(TRW, VCX, VCY, VCZ, &VVPX, &VVPY, &VVPZ);

  vectorized_cross_product(VCrossX, VCrossY, VCrossZ, VVPX, VVPY, VVPZ,&P0X, &P0Y,
      &P0Z);

  len = ((VCrossX*VCrossX)+(VCrossY*VCrossY))+(VCrossZ*VCrossZ);
  P0X = P0X/len;
  P0Y = P0Y/len;
  P0Z = P0Z/len;

  (*XFinal1) = HTuple();
  (*YFinal1) = HTuple();
  (*ZFinal1) = HTuple();

  (*XFinal2) = HTuple();
  (*YFinal2) = HTuple();
  (*ZFinal2) = HTuple();



  for (i=0; i<=(XL1.Num())-1; i+=1)
  {
    for (j=0; j<=(VRX.Num())-1; j+=1)
    {
      index = (i*(VRX.Num()))+j;
      a.Reset();
      a[0] = 0.0;
      a[1] = 0.0;
      a[2] = 0.0;

      u.Reset();
      u.Append(HTuple(XL1[i]));
      u.Append(HTuple(YL1[i]));
      u.Append(HTuple(ZL1[i]));

      b.Reset();
      b.Append(HTuple(P0X[index]));
      b.Append(HTuple(P0Y[index]));
      b.Append(HTuple(P0Z[index]));
      v.Reset();
      v.Append(HTuple(VCrossX[index]));
      v.Append(HTuple(VCrossY[index]));
      v.Append(HTuple(VCrossZ[index]));
      intersect_line3d(a, u, b, v, &ret);
      (*XFinal1).Append(HTuple(ret[0]));
      (*YFinal1).Append(HTuple(ret[1]));
      (*ZFinal1).Append(HTuple(ret[2]));
    }
  }

  for (i=0; i<=(XL2.Num())-1; i+=1)
  {
    for (j=0; j<=(VRX.Num())-1; j+=1)
    {
      index = (i*(VRX.Num()))+j;
      a.Reset();
      a[0] = 0.0;
      a[1] = 0.0;
      a[2] = 0.0;

      u.Reset();
      u.Append(HTuple(XL2[i]));
      u.Append(HTuple(YL2[i]));
      u.Append(HTuple(ZL2[i]));

      b.Reset();
      b.Append(HTuple(P0X[index]));
      b.Append(HTuple(P0Y[index]));
      b.Append(HTuple(P0Z[index]));
      v.Reset();
      v.Append(HTuple(VCrossX[index]));
      v.Append(HTuple(VCrossY[index]));
      v.Append(HTuple(VCrossZ[index]));
      intersect_line3d(a, u, b, v, &ret);
      (*XFinal2).Append(HTuple(ret[0]));
      (*YFinal2).Append(HTuple(ret[1]));
      (*ZFinal2).Append(HTuple(ret[2]));
    }
  }
  return;
}



using namespace Halcon;

// Procedure declarations
void find_max_concav_diff (Halcon::Hobject Image3, Halcon::HTuple *maxdiff, Halcon::HTuple *concavity);
void test_concavity (Halcon::Hobject Image3, Halcon::HTuple posx, Halcon::HTuple posy,
    Halcon::HTuple size1, Halcon::HTuple size2, Halcon::HTuple size3, Halcon::HTuple *MeanC,
    Halcon::HTuple *Mean);
// Procedures
void test_concavity (Halcon::Hobject Image3, Halcon::HTuple posx, Halcon::HTuple posy,
    Halcon::HTuple size1, Halcon::HTuple size2, Halcon::HTuple size3, Halcon::HTuple *MeanC,
    Halcon::HTuple *Mean)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  Circle, CircleBig, CircleSmall, RegionDifference;
  Hobject  RegionIntersection, RegionIntersection2;


  // Local control variables
  HTuple  Area1, Row, Column, Area2, Rows, Columns;
  HTuple  Grayval, RowsC, ColumnsC, GrayvalC;

  gen_circle(&Circle, posx, posy, size1);

  gen_circle(&CircleBig, posx, posy, size3);

  gen_circle(&CircleSmall, posx, posy, size2);

  difference(CircleBig, CircleSmall, &RegionDifference);
  intersection(RegionDifference, Image3, &RegionIntersection);

  area_center(RegionDifference, &Area1, &Row, &Column);
  area_center(RegionIntersection, &Area2, &Row, &Column);

  if (0 != ((Area1-Area2)<5))
  {
    get_region_points(RegionIntersection, &Rows, &Columns);
    get_grayval(Image3, Rows, Columns, &Grayval);

    intersection(Circle, Image3, &RegionIntersection2);
    get_region_points(RegionIntersection2, &RowsC, &ColumnsC);

    get_grayval(Image3, RowsC, ColumnsC, &GrayvalC);

    tuple_mean(GrayvalC, &(*MeanC));
    tuple_mean(Grayval, &(*Mean));
  }
  else
  {
    (*Mean) = 0.0;
    (*MeanC) = 0.0;
  }
  return;
}

void find_max_concav_diff (Halcon::Hobject Image3, Halcon::HTuple *maxdiff, Halcon::HTuple *concavity)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  Circle, CircleBig, CircleSmall, RegionDifference;
  Hobject  RegionIntersection, RegionIntersection2;


  // Local control variables
  HTuple  posx, posy, size1, size2, size3, maxr;
  HTuple  maxc, maxsz, maxdiff_sgn, r, c, sz, MeanC, Mean;
  HTuple  Rows, Columns, Grayval, RowsC, ColumnsC, GrayvalC;

  posx = 9.5;
  posy = 9.5;
  size1 = 2;
  size2 = 4;
  size3 = 6;
  maxr = 0;
  maxc = 0;
  maxsz = 0;
  (*maxdiff) = 0;
  maxdiff_sgn = 1;
  for (r=-3; r<=3; r+=1)
  {
    for (c=-3; c<=3; c+=1)
    {
      for (sz=-3; sz<=3; sz+=1)
      {
        test_concavity(Image3, posx+r, posy+c, size1, size2+sz, size3+sz, &MeanC,
            &Mean);
        if (0 != ((*maxdiff)<((MeanC-Mean).Abs())))
        {
          (*maxdiff) = (MeanC-Mean).Abs();
          maxdiff_sgn = (MeanC-Mean).Sgn();
          maxr = r;
          maxc = c;
          maxsz = sz;
        }
      }
    }
  }
  gen_circle(&Circle, posx+maxr, posy+maxc, size1);

  gen_circle(&CircleBig, posx+maxr, posy+maxc, size3+maxsz);

  gen_circle(&CircleSmall, posx+maxr, posy+maxc, size2+maxsz);

  difference(CircleBig, CircleSmall, &RegionDifference);
  intersection(RegionDifference, Image3, &RegionIntersection);
  get_region_points(RegionIntersection, &Rows, &Columns);
  get_grayval(Image3, Rows, Columns, &Grayval);

  intersection(Circle, Image3, &RegionIntersection2);
  get_region_points(RegionIntersection2, &RowsC, &ColumnsC);

  get_grayval(Image3, RowsC, ColumnsC, &GrayvalC);
  (*concavity) = 0;
  HTuple Sorted;
  tuple_sort (Grayval, &Sorted);

  if (0 != (maxdiff_sgn>0))
  {

    if (0 != ((  Sorted[Sorted.Num() - 2].D() )<(GrayvalC.Min())))
    {
      //concav
      (*concavity) = 1;
    }
    else
    {
      //planar
      (*concavity) = 0;
    }
  }
  else
  {
    if (0 != ((Sorted[2].D())>(GrayvalC.Max())))
    {
      //concav
      (*concavity) = 1;
    }
    else
    {
      //planar
      (*concavity) = 0;
    }
  }


  return;
}
